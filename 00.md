---
author: 张汉东
contributor:
- "http://www.epubor.com"
- "eCore v0.9.12.751 \\[ http://www.epubor.com/ecore.html \\]"
- Ultimate
- Epubor
date: 2019-01-01
identifier:
- 978-7-121-35485-4
- B07NW95M76
- "urn:uuid:273fd756-62f2-4858-8d67-99e08f24bba9"
language: zh
publisher: 电子工业出版社
title: Rust编程之道
---

![](./media/Image01168.jpg)

[]{#text00000.html}

**内容简介**

Rust是一门利用现代化的类型系统，有机地融合了内存管理、所有权语义和混合编程范式的编程语言。它不仅能科学地保证程序的正确性，还能保证内存安全和线程安全。同时，还有能与 C/C++语言媲美的性能，以及能和动态语言媲美的开发效率。

本书并非对语法内容进行简单罗列讲解，而是从四个维度深入全面且通透地介绍了Rust语言。从设计哲学出发，探索Rust语言的内在一致性；从源码分析入手，探索Rust地道的编程风格；从工程角度着手，探索Rust对健壮性的支持；从底层原理开始，探索Rust内存安全的本质。

本书涵盖了Rust 2018的特性，适合有一定编程经验且想要学习Rust的初学者，以及对Rust有一定的了解，想要继续深入学习的进阶者。\
\
\

未经许可，不得以任何方式复制或抄袭本书之部分或全部内容。

版权所有，侵权必究。\
\
\

**图书在版编目(CIP)数据**

Rust编程之道/张汉东著.---北京：电子工业出版社，2019.1

ISBN 978-7-121-35485-4

Ⅰ.①R... Ⅱ.①张... Ⅲ.①程序语言-程序设计 Ⅳ.①TP312

中国版本图书馆CIP数据核字(2018)第251334号\
\
\

策划编辑：刘恩惠

责任编辑：张春雨

印刷：

装订：

出版发行：电子工业出版社

北京市海淀区万寿路173信箱 邮编：100036

开本：787×1092 1/16 印张：36.25 字数：1018千字

版次：2019年1月第1版

印次：2019年1月第1次印刷

定价：128.00元\
\

凡所购买电子工业出版社图书有缺损问题，请向购买书店调换。若书店售缺，请与本社发行部联系，联系及邮购电话：(010)88254888，88258888。

质量投诉请发邮件至zlts@phei.com.cn，盗版侵权举报请发邮件至dbqq@phei.com.cn。

本书咨询联系方式：(010)51260888-819，faq@phei.com.cn。

[]{#text00001.html}

# 推荐序一 {#text00001.html#Aa8728708-6fca-4dea-985b-061240142526 .title-left}

Even though I had to read this book through Google Translate, *The Tao of Rust* is an extremely interesting book.It starts off explaining exactly why it is different:it\'s a book that gets you to think about Rust,and its perspective on the world.I only wish I could read it in its native tounge,as I\'m sure it\'s even better then!I have been working on Rust for six years now,and this book changed my perspective on some aspects of the language.That\'s very powerful!

即便我不得不通过谷歌翻译阅读这本书，但也不难发现《Rust编程之道》是一本非常有趣的书。它解释了Rust为何与众不同：这本书可以让你思考Rust，以及Rust语言所蕴含的世界观。我好希望能读懂中文原版书，因为我相信它会更精彩！我已经从事 Rust的相关工作六年了，这本书改变了我对Rust语言的某些看法。这非常强大！

------Steve Klabnik，Rust官方核心团队成员及文档团队负责人

[]{#text00002.html}

# 推荐序二 {#text00002.html#Abdca2435-e282-42b7-90f2-4a774e6e3b2e .title-left}

I knew Rust was a notoriously difficult programming language to learn,but it wasn\'t until I read the preface to *The Tao of Rust* ,by Alex Zhang,that I realized why it is so difficult.Alex writes:

Rust covers a wide range of knowledge,including object-oriented,functional programming,generics,underlying memory management,type systems,design patterns,and more.

Alex covers all of these topics and more in *The Tao of Rust* .A single text that ties all of this together will be invaluable for Rust learners.So far I\'ve read a couple of chapters translated from the original Chinese,and I can\'t wait to read more.

Rust语言难学，这已经是众所周知的了。但是直到我看到Alex（张汉东）的《Rust编程之道》的前言时，我才明白它为什么如此难学，Alex写道：

"Rust 涉及的知识范围非常广泛，涵盖了面向对象、函数式、泛型、底层内存管理、类型系统、设计模式等知识。"

《Rust编程之道》一书涵盖了所有这些主题和内容，并且将这些内容有机地联系在一起，这对于Rust的学习者来说是非常宝贵的。我阅读了本书部分内容的英文译稿后，就已经迫不及待地想要阅读更多的内容了。

------Patrick Shaughnessy，《Ruby原理剖析》原著作者

[]{#text00003.html}

# 推荐序三 {#text00003.html#Acfee9382-653c-42dd-a431-7f84774f3ac7 .title-left}

三年前，当我们决定为TiDB开发自有的分布式key-value存储系统TiKV时，我们首先要面对的就是选择什么语言的问题。当时，摆在我们面前的有多个选择：Go、C++、Java和Rust。在仔细评估之后，我们决定使用Rust，虽然那时候Rust并没有太多成功的项目案例。我清晰地记得当时选择一门语言的条件如下。

· 我们需要一门安全的语言，让我们处理内存和多线程的时候更加游刃有余，不用担心类似垂悬指针、数据争用等问题。

· 我们需要一门高性能的静态语言，以便更好地与内存、CPU打交道，不用担心GC引起的延迟突然上升等问题。

· 我们需要一个强大的包管理系统，以避免陷入编译构建工具的细节中，也不用为管理多个版本的库而发愁。

· 我们需要一个友善的社区，在需要时能从这个社区得到帮助，与大家一起成长。

以上这些条件，Rust全部满足。事实也没有让我们失望。我们使用Rust快速地对TiKV进行了迭代。现在，TiKV 不仅大量用在生产环境中，还进入了 CNCF 基金会，成为了一个在Cloud上面构建其他服务的原生基础组件。

但是，我们使用Rust的历程并不是一帆风顺的。在早期，Rust相关的文档非常稀缺，网上也没有很好的参考资料，更别提专业系统的 Rust书籍了。所以，当我拿到汉东同学的《Rust编程之道》时，我是非常兴奋的。本书不仅介绍了 Rust 的基础知识，还详细地解释了 Rust里面非常难以理解的所有权系统、内存模型、并发编程等特性。尤其是所有权这个概念，对很多同学来说，所有权就是从其他语言切换到Rust的第一个拦路虎，而汉东同学在本书中进行了细致清晰的讲解，相信大家会有一种"哦，原来如此"的感慨。更难能可贵的是，本书还从工程角度讲解了如何使用Rust来编写健壮的应用程序，提升产品质量。

Rust是一门相对难学的语言，我个人认为它的学习曲线比C++的学习曲线更陡峭，但我相信，通过《Rust编程之道》，大家能快速掌握Rust，体验使用Rust编程的乐趣，也能更快地在项目中使用Rust来保证程序的健壮性。如果你遇到了困难，不用害怕，你可以很方便地从Rust社区得到帮助。

欢迎来到 Rust的世界！！！

------唐刘，PingCAP首席架构师，TiKV负责人

[]{#text00004.html}

# 序 {#text00004.html#A86c660b8-8936-4227-8216-dbeeba0d0a24 .title-left}

当我2015年开始学习Rust的时候，我绝对没有想过要写一本Rust编程的书。

**缘起**

当时我刚刚翻译完《Ruby原理剖析》一书，开始对底层开发产生了一点点兴趣。从2006年入行以来，我就一直和动态语言打交道。虽然自己也想学习底层开发，但能选择的语言几乎只有 C++。我在学校里浅浅地学过 C++这门语言，也许是第一印象作怪，总难以提起对C++的兴趣。

当Rust 1.0发布时，我去官方网站了解了一下Rust语言，发现它的主要特点有以下几方面：

· 系统级语言

· 无GC

· 基于LLVM

· 内存安全

· 强类型+静态类型

· 混合编程范式

· 零成本抽象

· 线程安全

我一下子就被这些鲜明的特性"击中"了，从此开始了Rust的学习。

**再一次爱上编程**

第一次爱上编程是在上小学时。父亲给我买回来一台金字塔学习机，这台学习机有两种功能，一种是学习Logo语言，另一种是玩卡带游戏。编写Logo语言就是用小海龟画图，也许是因为太早了，也许是因为没有人引导，那时的我选择了痛快地玩游戏。总想着先玩游戏，再去学怎么编程，然后还幻想着能不能用 Logo 语言编写一个游戏。其实这时候的我对编程更多的是一种憧憬，并没有在学习编程上付出更多的实际行动。

第二次爱上编程是在大学初次学习C语言的时候。我本可以选择计算机科学专业，但是最后还是选了电子信息科学与技术专业。这样选是因为我想把软硬件都学了。想法是好的，可惜实施起来并不容易。最后的结果就是，软硬件都没学好。

第三次爱上编程是在遇到Ruby语言的时候。当时我在用Java，并且已经完全陷入了Java语言和Web框架纷繁复杂的细节中，痛苦不堪。Ruby on Rails框架的横空出世，把我从这种状态中解救了出来。Ruby语言的优雅和自由，以及"让程序员更快乐"的口号深深地吸引了我。这一次我是真正爱上了编程，并且积极付诸行动去学习和提升自己。此时也恰逢互联网创业大潮的开始，Ruby语言的开发效率让它迅速成为创业公司的宠儿，因此，我也借着Ruby这门语言参与到了这股创业洪流中。

第四次爱上编程是在遇到Rust的时候。此时，创业洪流已经退潮。技术圈有句话，叫"十年一轮回"。当年喜欢Ruby给开发过程带来的快乐，但是随着时代的变革和业务规模的增长，我不禁开始重新思考一个问题：何谓快乐？真正的快乐不仅仅是写代码时的"酸爽"，更应该是代码部署到生产环境之后的"安稳"。Rust恰恰可以给我带来这种"双重快乐"体验。

**为什么是Rust**

社区中有人模仿阿西莫夫的机器人三大定律，总结了程序的三大定律 ^[\[1\]](#text00004.html#nE317000745E947DFA0DCD59F5E5C0E5A){#text00004.html#nE317000745E947DFA0DCD59F5E5C0E5As}^ ：

· 程序必须正确。

· 程序必须可维护，但不能违反第一条定律。

· 程序必须高效，但不能违反前两条定律。

程序的正确性，一方面可以理解为该程序满足了实际的问题需求，另一方面是指满足了它自身的程序规约。那么如何保证程序的正确性呢？首先，可以通过对程序的各种测试、断言和错误处理机制，来保证其满足实际的问题需求。其次，在数学和计算机科学已经融合的今天，通过较为成熟的类型理论即可保证程序自身的规约正确。

以我最熟悉的 Ruby 语言为例，程序的正确性必须依赖于开发者的水平，并需要大量的测试代码来保证正确性。即便在100%测试覆盖率的条件下，也经常会遇到NilError之类的空指针问题。也就是说，Ruby程序自身的正确性还没有得到保证。以此类推，C、C++、Python、Java、JavaScript等语言都有同样的问题。

而函数式编程语言在这方面要好很多，尤其是号称纯函数式的 Haskell 语言，它具有融合了范畴理论的类型系统，利用了范畴理论自身的代数性质和定律保证了程序自身的正确性。然而，Haskell也有比较明显的缺点，比如它不满足上述第三条定律，运行效率不高。

反观Rust语言，对程序的三定律支持得恰到好处。它借鉴了Haskell的类型系统，保证了程序的正确性。但还不止于此，在类型系统的基础上，Rust借鉴了现代C++的内存管理机制，建立了所有权系统。不仅保证了类型安全，还保证了内存安全。同时，也解决了多线程并发编程中的数据竞争问题，默认线程安全。再来看代码的可维护性，Rust代码的可读性和抽象能力都是一流的。不仅拥有高的开发效率，还拥有可以和C/C++媲美的性能。当然，没有银弹，但Rust就是我目前想要的语言。

目前Rust被陆续应用在区块链、游戏、WebAssembly技术、机器学习、分布式数据库、网络服务基础设施、Web框架、操作系统和嵌入式等领域。时代在变化，未来的互联网需要的是安全和性能并重的语言，Rust必然会在其中大放异彩。

**学习Rust带来了什么收获**

Rust是一门现代化的语言，融合了多种语言特性，而且Rust语言可以应用的领域范围非常广泛。在学习Rust的过程中，我发现自己的编程能力在很多方面存在短板。突破这些短板的过程实际上就是一次自我提升的过程。

Rust 是一门成长中的新语言，学习 Rust，跟随 Rust 一起成长，可以体验并参与到一门真正工业化语言的发展进程中，感觉就像在创造历史。虽然我并未给Rust语言提交过PR，但也为Rust语言和社区多次提交过Bug，以及文档和工具的改进意见。

Rust自身作为一个开源项目，算得上是开源社区中的"明星"项目了。学习Rust的过程加深了我对开源社区的认识，也开拓了我的眼界。

**为什么要写这本书**

在学习Rust一年之后，我写下了《如何学习一门新语言》一文，其中记录了我学习Rust的心得，这篇文章颇受好评。也正因为这篇文章，电子工业出版社的刘恩惠编辑找到了我，并询问是否可以出一本Rust编程的书籍。我当时也正想通过一本书来完整地表达自己的学习心得，再加上中文社区中没有较全面系统的Rust书籍，于是，一拍即合。

写书的过程可以形容为痛并快乐着。Rust语言正值成长期，很多语言特性还在不断地完善。举一个极端的例子，比如写下某段代码示例并成功编译后，过了三天却发现它无法编译通过了。于是，我再一次跟进Rust的RFC、源码、ChangeLog去看它们的变更情况，然后再重新修订代码示例。这个过程虽然痛苦，但改完之后会发现Rust的这个改进确实是有必要的。在这个过程中，我看到了Rust的成长，以及Rust团队为保证语言一致性和开发者的开发体验所付出的努力，让我感觉自己花再多时间和精力去修改本书的内容都是值得的。

话说回来，任何人做事都是有动机或目的的，我也不例外。我写这本书的目的主要有以下三个。

· 为Rust中文社区带来一本真正可以全面系统地学习Rust的书。

· 以教为学。在写作的过程中，让自己所学的知识进一步内化。

· 传播一种自学方法。本书内容以Rust语言的设计哲学为出发点，按照从整体到细节的思路逐个阐述每个语言特性，希望读者可以产生共鸣。

**结语**

我自己作为本书的第一位读者，目前对这本书是非常满意的。衷心希望每一位读者都能从本书中收获新知。当然，我也知道不可能让每一位读者都满意。在我看来，写书不仅是在传播知识和思想，更是一种交流和沟通。所以，当你不满意的时候，可以来找我交流，提出更多建设性意见，帮助我成长。我争取在写下一本书的时候，让更多的人满意。而且，如果你的建议确实中肯，让我得到了成长，我也为你准备了不错的小礼物。

------------------------------------------------------------------------

[\[1\]](#text00004.html#nE317000745E947DFA0DCD59F5E5C0E5As){#text00004.html#nE317000745E947DFA0DCD59F5E5C0E5A} https://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b

[]{#text00005.html}

# 前言 {#text00005.html#A6add9b71-0682-41b8-bef6-1b5a168651aa .title-left}

在我刚开始学习Rust的时候，在社区里听到最多的声音就是"Rust学习曲线陡"。已经有一定编程经验的人在学习一门新语言时，都喜欢直接上手写代码，因为这样可以快速体验这门语言的特色。对于大多数语言来说，这样确实可以达到一定的学习目的。但是当他们在初次学习Rust的时候，就很难通过直接上手来体验这种快感。

我第一次学习Rust时就遇到了这样的情况。我按以往的编程经验直接写下了代码，但是编译无法通过；可是有时候简单调换两行代码的顺序，程序就能顺利编译成功了，这让我非常困惑。我想这也是大多数人感觉"Rust学习曲线陡"的原因吧。经过和Rust编译器的多次"斗争"之后，我不得不重新反思自己的学习方法。看样子，Rust 编译器暗含了某种规则，只要程序员违反了这些规则，它就会检查出来并阻止你。这就意味着，作为程序员，你必须主动理解并遵守这些规则，编译器才能和你"化敌为友"。

所以，我就开始了对Rust的第二轮学习，忘掉自己以往的所学，抱着初学者的心态，从零开始系统地学习Rust。然而，事情并没有这么简单。

Rust官方虽然提供了*Rust Book* ，但是内容的组织非常不友好，基本就是对知识点的罗列，系统性比较差。后来官方也意识到了这个问题，推出了第2版的*Rust Book* ，内容组织方面改善了很多，对学习者也非常友好，但系统性还是差了点。后来又看了国内Rust社区组织群友们合著的*Rust Primer* ，以及国外的*Programming Rust* ，我才对Rust建立了基本的认知体系。

直到此时，我才意识到一个重要的问题：Rust学习曲线陡的根本原因在于Rust语言融合了多种语言特性和多种编程范式。这就意味着，Rust涉及的知识范围非常广泛，涵盖了面向对象、函数式、泛型、底层内存管理、类型系统、设计模式等知识。从底层到上层抽象，从模式到工程化健壮性，无所不包。可以说，Rust是编程语言发展至今的集大成者。对于大多数Rust语言的初学者来说，他掌握的知识体系范围是小于Rust所包含的知识量的，所以在学习Rust的过程中会遇到无法理解的内容。

我在学习Rust之前，所掌握的编程语言知识体系大多是和拥有GC的动态语言相关的，对于底层内存管理知之甚少。所以在我学习Rust所有权的时候，就很难理解这种机制对于内存安全的意义所在；而我所认识的一些拥有 C 语言编程经验的朋友，在学习 Rust 时面临的问题是，难以理解Rust支持的上层抽象，对他们来说，Rust中融合的类型系统和编程范式就是他们学习道路上的"拦路虎"；对于拥有 Haskell 等函数式编程经验的朋友，会感觉 Rust的类型系统很容易理解，但是底层的内存管理和所有权机制又成了需要克服的学习障碍；来自C++编程圈的朋友，尤其是懂现代C++的朋友，对Rust所有权机制理解起来几乎没有困难，但是类型系统和函数式编程范式可能会阻碍他们的学习。当然，如果正好你没有上述情况，那说明你的相关知识体系已经很全面了，你在Rust的学习之路上将会非常顺利。

这是不是意味着，在学习Rust之前需要把其他语言都学一遍呢？答案是否定的。

Rust编程语言虽然融合了很多其他语言的特性和范式，但它不是进行简单的内容堆叠，而是有机地融合了它们。也就是说，Rust遵循着高度的一致性内核来融合这些特性。我们只需要从Rust的设计哲学出发，牢牢地把握它的设计一致性，就可以把它的所有特性都串起来，从而达到掌握它的目的。这正是本书遵循的写作逻辑。

**本书特点**

**从设计哲学出发，探索 Rust 语言的内在一致性** 。设计哲学是一门优秀编程语言保持语言一致性的关键所在。设计哲学是语言特性和语法要素设计的诱因和准则。理解Rust语言的设计哲学，有助于把握Rust语言的内核与一致性，把Rust看似纷繁复杂的特性都系统地串起来。

**从源码分析入手，探索Rust地道的编程风格** 。Rust是一门自举的语言，也就是说，Rust语言由Rust自身实现。通过阅读Rust标准库和一些第三方库的源码，不仅可以深入理解Rust提供的数据类型和数据结构，更能体验和学习地道的Rust编程风格。

**从工程角度着手，探索 Rust 对健壮性的支持** 。Rust 通过类型系统、断言、错误处理等机制保证内存安全的同时，还保证了系统的健壮性。从工程角度去看Rust，才能看到Rust对系统健壮性的支持是多么优雅。

**从底层原理开始，探索Rust内存安全的本质** 。只有深入底层，才能理解Rust所有权机制对于内存安全的意义。而且可以进一步理解Rust的类型系统，以及Unsafe Rust存在的必要性。

**读者群体**

适合本书的读者群体包括：

· 有一定编程经验，想要学习Rust的初学者。

· 对Rust有一定了解，还想对Rust深入学习的进阶者。

本书不适合完全没有编程基础的人学习。

**如何阅读本书**

对于Rust初学者，建议按照章节顺序去阅读。因为本书每一章内容基本都依赖于前一章内容的前置知识。

对于Rust有一定了解的朋友，可以选择你感兴趣的章节去阅读。因为本书的每一章也是对一个垂直主题的深入探讨。

一些章节的开头罗列出了通用概念，这是为了更通透地讲解相关知识的来龙去脉。如果你对这部分内容不了解，那么建议你把这部分内容（属于前置知识）认真看完再去看后面的内容。如果你对这部分内容已经有了充分的了解，那么完全可以跳过，直接选择你最关心的内容去阅读。

**章节概述**

**第1章 新时代的语言** 。这一章将从Rust语言的发展历史概述开始，引出Rust的设计哲学，通过设计哲学进一步阐述Rust的语言架构。该语言架构也是本书组织内容时遵循的准则之一。这一章还将介绍 Rust 语言社区的现状和未来展望。最重要的是，这一章将介绍 Rust代码的执行流程，这对于理解本书后面的章节会有所帮助。

**第 2 章 语言精要** 。学习任何一门语言时，首先要做的就是了解其语法。这一章将罗列Rust语言中的常用语法，但不是简单罗列，而是遵循一定的逻辑进行罗列。在介绍语法之前，这一章会先对Rust语言的基本构成做整体概述。然后将介绍一个非常重要的概念：表达式。它是Rust语法遵循的最简单的准则之一。接下来才会依次介绍Rust中最常用的语法，让读者对Rust语言有一个初步的了解。

**第 3 章 类型系统** 。类型系统是现代编程语言的重要支柱。这一章首先将以通用概念的形式介绍类型系统相关的概念，目的是帮助不了解类型系统的读者建立初步认知。接下来将从三方面阐述Rust的类型系统。为了理解Rust基于栈来管理资源的思想，有必要先了解Rust中对类型的分类，比如可确定大小类型、动态大小类型和零大小类型等。这一章还将介绍Rust类型推导功能及其不足。接下来将介绍Rust中的泛型编程。泛型是Rust类型系统中最重要的一个概念。最后会介绍Rust 的"灵魂"，trait 系统。对类型系统建立一定的认知，有利于学习后面的内容。

**第 4 章 内存管理** 。这一章首先将介绍底层内存管理的通用概念。在此基础上，围绕内存安全这个核心，从变量定义到智能指针，逐渐阐述Rust中资源管理的哲学。这部分内容是真正理解Rust所有权机制的基础。

**第 5 章 所有权系统** 。这一章首先会介绍关于值和引用语义的通用概念，然后在此基础上探讨Rust的所有权机制。读者将看到，Rust如何结合类型系统和底层内存管理机制，以及上层值和引用的语义形成现在的Rust所有权系统。然后，进一步围绕内存安全的核心，阐述借用检查和生命周期参数的意义。通过这一章的学习，读者将会对Rust的所有权系统有全面深入的了解。

**第6章 函数、闭包和迭代器** 。在对Rust的类型系统和内存安全机制有了一定了解之后，我们将开始深入学习 Rust 编程最常用的语法结构。函数是 Rust 中最常用的语法单元。Rust的函数承载了诸多函数式编程范式的特性，比如高阶函数、参数模式匹配等，同时也承载了面向对象范式的特性，比如为结构体及其实例实现方法，实际上就是一个函数调用的语法糖。然后将介绍闭包的用法和特性，帮助读者对闭包建立全面深入的认知，更重要的是，通过学习闭包的实现原理，进一步了解Rust中零成本抽象的哲学思想。最后介绍迭代器模式，以及Rust中的迭代器实现机制。迭代器也是Rust最常用的特性，通过这一章的学习，你将彻底了解迭代器。

**第7章 结构化编程** 。这一章将对Rust混合范式编程进行探讨，会重点介绍Rust中的结构体和枚举体，以及它们如何在日常编程中以面向对象风格编程。同时，还将介绍三种设计模式，前两种是Rust标准库以及第三方库常用的设计模式，最后是一种合理利用Rust资源管理哲学的设计模式。通过学习这一章的内容，有利于掌握地道的Rust编程风格。

**第 8 章 字符串与集合类型** 。字符串是每门编程语言最基本的数据类型，Rust 自然也不例外。出于内存安全的考虑，Rust中的字符串被分为了多种，并且语言自身没有自带正则表达式引擎。这一章将从字符编码开始，围绕内存安全，对Rust中的字符和字符串做彻底梳理，并且阐述如何在没有正则表达式引擎的情况下，满足字符串进行匹配搜索等的需求。集合类型也是编程中必不可少的数据结构。这一章将着重介绍动态数组Vector和Key-Value映射集HashMap 的使用，而且还会深入挖掘 HashMap 底层的实现原理，介绍 Rust 标准库提供的HashMap安全性，进一步探讨如何用Rust实现一个生产级的数据结构。最后将通过探讨一个Rust安全漏洞的成因，来帮助读者正确理解容量的概念，从而写出更安全的代码。

**第 9 章 构建健壮的程序** 。对于如何构建健壮的系统，Rust 给出了非常工程化的解决方案。Rust将系统中的异常分为了多个层次，分别给出了对应的处理手段。在这一章，读者将学习Rust是如何以分层的错误处理解决方案来帮助开发者构建健壮系统的。

**第10章 模块化编程** 。现代编程语言的一大特色就是可以方便地进行模块化，这样有利于系统的设计、维护和协作。Rust在模块化编程方面做得很好。这一章首先将介绍Rust强大的包管理系统Cargo。然后会以真实的代码实例阐述Rust的模块系统，并且将包含Rust 2018版本中模块系统的重大改进。最后将以一个完整的项目为例阐述如何使用 Rust 开发自己的crate。

**第11章 安全并发** 。Rust从两方面支持并发编程。首先，利用类型安全和内存安全的基础，解决了多线程并发安全中的痛点：数据竞争。Rust可以在编译时发现多线程并发代码中的安全问题。其次，Rust为了达成高性能服务器开发的目标，开始全面拥抱异步开发。这一章将从线程安全的通用概念开始，从Rust多线程并发讲到异步并发支持，带领读者逐步形成全面、深入、通透的理解。

**第12章 元编程** 。元编程即程序生成程序的能力。Rust为开发者提供了多种元编程能力。这一章将从反射开始介绍Rust中的元编程。虽然Rust的反射功能没有动态语言的那么强大，但是Rust提供了强大的宏系统。这一章将从Rust的编译过程出发，带领读者深入理解Rust的宏系统的工作机制，并且以具体的实例帮助读者理解编写宏的技巧。从声明宏到过程宏，再到编译器插件，以及第三方库syn和quote最新版的配合使用，都将在本章进行阐述。

**第13章 超越安全的边界** 。前面的章节内容基本都是建立在Safe Rust的基础上的。而这一章将主要围绕Unsafe Rust的内容来构建，主要分为4大部分。首先将介绍Unsafe Rust的基本语法和特性。然后，围绕基于Unsafe进行安全抽象的核心，阐述Unsafe Rust开发过程中可能引起未定义行为的地方，以及相应的解决方案。然后介绍 FFI，通过具体的实例来阐述Rust如何和其他语言交互，涉及C、C++、Ruby、Python、Node.js等语言，还将介绍相关的第三方库。最后，将介绍未来互联网的核心技术 WebAssembly，以及 Rust 如何开发WebAssembly和相关的工具链。

相信通过这13章的内容，读者将会对Rust有全面、深入和系统的认识。

**勘误及更多资源**

有人的地方就有Bug，此书当然也不例外。写书不仅是正确地传播知识和思想的途径，更是一种交流和沟通的方式。如果你发现本书中的任何错误、遗漏和解释不清楚的地方，欢迎提出反馈。

随书源码地址：https://github.com/ZhangHanDong/tao-of-rust-codes

::: center
![](./media/Image00001.jpg){.u54483}
:::

**勘误说明：**

· 直接提交issues。

· 标明具体的页码、行数和错误信息。

· 积极提出勘误者将获得合金Rust勋章一枚。

**更多的学习资源：**

· 官方doc.rust-lang.org列出了很多学习文档和资源。

· 订阅Rust每日新闻 ^[\[1\]](#text00005.html#n169E000D5253448B8F1E50F394EF6EA5){#text00005.html#n169E000D5253448B8F1E50F394EF6EA5s}^ ，了解Rust社区生态发展，学习Rust。

**致谢**

首先，我要感谢Rust社区中每一位帮助过我的朋友，没有你们的奉献，就没有这本书。

感谢Mike组织社区编写的免费书籍*Rust Primer* 。感谢Rust社区中不知名的翻译者翻译官方的*Rust Book* 。感谢知乎《Rust编程》专栏作者辛苦的写作。感谢KiChjang、ELTON、CrLF0710、F001、Lingo、tennix、iovxw、wayslog、Xidorn、42、黑腹喵等其他社区里的朋友们，你们在我学习的过程中给予了我无私的帮助和解答，Rust社区有你们真好。感谢知道我写作并一直鼓励和支持我的朋友们。衷心希望Rust社区可以一直这么强大、温柔和友好。

然后，我要感谢电子工业出版社的刘恩惠编辑。感谢你给了我这个机会，让这本书从想法成为了现实。

最后，感谢我的妻子宋欣欣，因为她的温柔、大度、包容、信任和支持，才让我能够踏实且满含信心地做我自己想做的事。感谢我的父母，正是他们的培养，才使我具有积极、坚持不懈做事情的品格。

**读者服务**

轻松注册成为博文视点社区用户（www.broadview.com.cn），扫码直达本书页面。

· **下载资源** ：本书如提供示例代码及资源文件，均可在 [下载资源]{.underline} 处下载。

· **提交勘误** ：您对书中内容的修改意见可在 [提交勘误]{.underline} 处提交，若被采纳，将获赠博文视点社区积分（在您购买电子书时，积分可用来抵扣相应金额）。

· **交流互动** ：在页面下方 [读者评论]{.underline} 处留下您的疑问或观点，与我们和其他读者一同学习交流。

页面入口：http：//www.broadview.com.cn/35485

::: center
![](./media/Image00002.jpg){.u54483}
:::

------------------------------------------------------------------------

[\[1\]](#text00005.html#n169E000D5253448B8F1E50F394EF6EA5s){#text00005.html#n169E000D5253448B8F1E50F394EF6EA5} https://github.com/RustStudy/rust_daily_news

[]{#text00006.html}

# 目录

[推荐序一](#text00001.html#Aa8728708-6fca-4dea-985b-061240142526)

[推荐序二](#text00002.html#Abdca2435-e282-42b7-90f2-4a774e6e3b2e)

[推荐序三](#text00003.html#Acfee9382-653c-42dd-a431-7f84774f3ac7)

[序](#text00004.html#A86c660b8-8936-4227-8216-dbeeba0d0a24)

[前言](#text00005.html#A6add9b71-0682-41b8-bef6-1b5a168651aa)

[第1章 新时代的语言](#text00007.html#A13345fa2-ca9e-4443-b387-3be4be4ad807)

[1.1 缘起](#text00007.html#A2e390017-16f6-4767-888c-ac30171cf3dd)

[1.2 设计哲学](#text00007.html#Aed7f0019-4d35-4813-9045-1325129be2ec)

[1.2.1 内存安全](#text00007.html#A5d590019-f625-42fa-977c-68d5497c12b9)

[1.2.2 零成本抽象](#text00007.html#A25bb001a-ea7e-4415-bb38-2c42ad6ba144)

[1.2.3 实用性](#text00007.html#A93e9001b-07a4-4ef1-b0aa-5974bb850d10)

[1.3 现状与未来](#text00007.html#A8646001d-26aa-439b-b693-15e20ec5604f)

[1.3.1 语言架构](#text00007.html#A4a8f001e-2d5f-490e-96b7-70917d6acd94)

[1.3.2 开源社区](#text00007.html#A261a001f-2076-4801-990e-463085bc922e)

[1.3.3 发展前景](#text00007.html#Ae4fd001f-497d-47f3-a529-2e1a1a0af2a6)

[1.4 Rust代码如何执行](#text00007.html#Ac7100020-27df-4646-a368-affa8b0d076b)

[1.5 小结](#text00007.html#A9ede0020-c27b-442f-932d-9310ae9bacb4)

[第2章 语言精要](#text00008.html#A672b422f-6011-45a1-9bcd-716732b44efd)

[2.1 Rust语言的基本构成](#text00008.html#Aa2840021-48d9-4370-ab36-0cfd5e696c49)

[2.1.1 语言规范](#text00008.html#A2c6c0021-f6fc-4751-ba12-d6c630810c78)

[2.1.2 编译器](#text00008.html#Ad2310022-0fba-48fe-b1ff-6a55c6b38b9d)

[2.1.3 核心库](#text00008.html#A35000022-235b-4f28-85b5-0951fec89bfe)

[2.1.4 标准库](#text00008.html#Ac8a30022-7b3b-488a-b0be-7226a15dd514)

[2.1.5 包管理器](#text00008.html#Abc020023-3d4a-4ac4-bdb1-499e34da314d)

[2.2 语句与表达式](#text00008.html#Af96f0023-36f7-4614-a364-822d1ceeb79f)

[2.3 变量与绑定](#text00008.html#A02a60024-1356-4822-a930-cc2f737c5417)

[2.3.1 位置表达式和值表达式](#text00008.html#A14a50025-c010-43d3-80fd-93a8209276c1)

[2.3.2 不可变绑定与可变绑定](#text00008.html#Aea3c0025-eab9-4870-924d-035ba9f5797e)

[2.3.3 所有权与引用](#text00008.html#A9e910026-4c7a-400a-ad95-2fb171bfee0f)

[2.4 函数与闭包](#text00008.html#A23b60027-4382-4a74-b676-671aa8cbb163)

[2.4.1 函数定义](#text00008.html#Ad6a00027-5da3-48d7-9cd2-57b1a68a3445)

[2.4.2 作用域与生命周期](#text00008.html#A023e0028-d832-4805-9640-e97f0c7d9681)

[2.4.3 函数指针](#text00008.html#A5a270029-76fb-4450-b1b2-915c6625f59d)

[2.4.5 CTFE机制](#text00008.html#A8e32002a-bbd2-404e-b7b9-b554f687c760)

[2.4.6 闭包](#text00008.html#Aa887002a-4299-4cc8-b210-73f59138bd82)

[2.5 流程控制](#text00008.html#A88d9002c-ddd7-4f48-95bd-46cebb4c290d)

[2.5.1 条件表达式](#text00008.html#Ae0d2002c-03b0-461b-a6a9-1c2337cb2526)

[2.5.2 循环表达式](#text00008.html#A238b002d-8410-4d72-9e47-69cc175f4cfd)

[2.5.3 match表达式与模式匹配](#text00008.html#Ac22a002e-4b82-4a6d-a0b6-6e18c38d7ca0)

[2.5.4 if let和while let表达式](#text00008.html#Abd0f002f-43a0-4860-a538-d5dc5f2d05c0)

[2.6 基本数据类型](#text00008.html#A24e90030-c749-401f-8eed-4d5e097d3529)

[2.6.1 布尔类型](#text00008.html#A38910030-98d3-409f-9989-bfe60f40df63)

[2.6.2 基本数字类型](#text00008.html#A4d9d0030-a018-491e-8cb4-acd00b11f933)

[2.6.3 字符类型](#text00008.html#A495a0031-288c-4de3-8e79-aefe9ee83ee8)

[2.6.4 数组类型](#text00008.html#A77800032-34c3-4ef9-89fc-8ea5bd7ca97f)

[2.6.5 范围类型](#text00008.html#A6f4d0033-8d9e-45d0-b823-02f0c0377bfc)

[2.6.6 切片类型](#text00008.html#Afb960033-2f11-463c-80aa-3dd214949582)

[2.6.7 str字符串类型](#text00008.html#Acaee0034-a571-4e7d-8914-a4f6fbd53507)

[2.6.8 原生指针](#text00008.html#Aacf50035-55ad-46e4-925e-367bd7bd0639)

[2.6.9 never类型](#text00008.html#A78c30035-5b63-4f96-a560-794d1153ec23)

[2.7 复合数据类型](#text00008.html#A9e880036-9172-48b5-b36b-97820775cc55)

[2.7.1 元组](#text00008.html#A4f480036-58f0-42ac-9540-4110607e9f7f)

[2.7.2 结构体](#text00008.html#Af1720037-6ed8-41c7-b571-e1a7f82e6b70)

[2.7.3 枚举体](#text00008.html#A60a6003a-0c25-4594-be4a-387d9ed9617b)

[2.8 常用集合类型](#text00008.html#Aee9a003c-aeec-4146-9f02-0037ef0e9b86)

[2.8.1 线性序列：向量](#text00008.html#A3df4003c-ea0b-43d6-bf29-d23146263b1f)

[2.8.2 线性序列：双端队列](#text00008.html#Acfba003d-21bf-4c16-9ba9-8b64a8adfd68)

[2.8.3 线性序列：链表](#text00008.html#Ac072003e-24a7-454d-851c-7c6e90f443fb)

[2.8.4 Key-Value映射表：HashMap和BTreeMap](#text00008.html#A53bf003e-dc93-4783-8dd3-8fb09e8ca2ff)

[2.8.5 集合：HashSet和BTreeSet](#text00008.html#Aaf1f003f-0101-4d93-bc0d-54454f77f2f5)

[2.8.6 优先队列：BinaryHeap](#text00008.html#A74090040-c484-45e4-bbd4-13cf6e6ae96b)

[2.9 智能指针](#text00008.html#Afe8d0040-705b-44db-bee3-469d25c8777f)

[2.10 泛型和trait](#text00008.html#A5dad0041-8417-4f7c-bd06-302211239349)

[2.10.1 泛型](#text00008.html#A580713c2-16a0-4765-af13-547beecc42c2)

[2.10.2 trait](#text00008.html#Ac782f051-1d93-4586-828e-878262cf08c5)

[2.11 错误处理](#text00008.html#Ad4640045-098d-4091-8b59-91ca5c96e07e)

[2.12 表达式优先级](#text00008.html#Ad54f0046-9a46-455b-ab97-fc87b5bc82ea)

[2.13 注释与打印](#text00008.html#Abdbf0046-f00c-46c1-9f22-d4216d2cc031)

[2.14 小结](#text00008.html#A083b0048-8361-44ae-a371-8a144dcfb684)

[第3章 类型系统](#text00009.html#A94bb2754-a86f-4838-8885-f163e89f33a0)

[3.1 通用概念](#text00009.html#Afa6f0049-0a2b-4377-9c2c-9acd37489509)

[3.1.1 类型系统的作用](#text00009.html#Aad320049-ce3b-4f34-81fa-7abcf343778c)

[3.1.2 类型系统的分类](#text00009.html#A8579004a-7454-4a12-a64d-11a6e13c61cd)

[3.1.3 类型系统与多态性](#text00009.html#A4cbd004b-4c73-4335-94c6-669f6ddca6e9)

[3.2 Rust类型系统概述](#text00009.html#Aeac8004b-415b-4ec3-a957-d1c3bd5832d4)

[3.2.1 类型大小](#text00009.html#Aec09004b-4ecb-486d-8ee5-8597c3111cc0)

[3.2.2 类型推导](#text00009.html#Aaa400050-88a0-49fd-ba29-f811451b3074)

[3.3 泛型](#text00009.html#Aabdf0052-ee35-47ef-ae71-0c500e528223)

[3.3.1 泛型函数](#text00009.html#A078c0052-2f73-4218-a3d8-a25be7a7a9f4)

[3.3.2 泛型返回值自动推导](#text00009.html#A87000054-8733-4801-9986-35924b78445b)

[3.4 深入trait](#text00009.html#Ad6c10054-cf7b-4dd8-bfe6-57e5834d8fcc)

[3.4.1 接口抽象](#text00009.html#A86e30055-0f2a-4e3a-8f10-b531b55e576c)

[3.4.2 泛型约束](#text00009.html#A293e005b-8a83-4b12-ab0a-5c84a09676d6)

[3.4.3 抽象类型](#text00009.html#A6cde005d-99e2-4a05-89bd-11d2c3efb2d6)

[3.4.4 标签trait](#text00009.html#A7dfc0063-ba68-4754-9da9-f7db224e7ad3)

[3.5 类型转换](#text00009.html#A039f0069-6289-4ca8-8c90-8ac249909278)

[3.5.1 Deref解引用](#text00009.html#A35e30069-d512-4aec-a49d-9d7b55a00157)

[3.5.2 as操作符](#text00009.html#A582e006c-8455-4e37-bc01-f9a41d3ece59)

[3.5.3 From和Into](#text00009.html#Abad1006e-80f3-4150-bed8-333bd41ad773)

[3.6 当前trait系统的不足](#text00009.html#A3a27006f-0de1-4a2c-8e40-bc16c5ff489c)

[3.6.1 孤儿规则的局限性](#text00009.html#Ad3940070-4ee5-4864-8f8f-f0865dbb6e8b)

[3.6.2 代码复用的效率不高](#text00009.html#A00aa0071-0d6a-4cd0-960e-56d298b6ecad)

[3.6.3 抽象表达能力有待改进](#text00009.html#A14b40073-087d-46d9-8dfb-18d536a13bb6)

[3.7 小结](#text00009.html#A01890074-e80f-4176-a99f-1e1692d4d06a)

[第4章 内存管理](#text00010.html#Ae0097119-f28f-4899-a334-6385f17384a3)

[4.1 通用概念](#text00010.html#A33d30075-79a8-4d4a-9a0f-77bcc2957b56)

[4.1.1 栈](#text00010.html#A1abd0076-0983-4906-8609-074ddcbbd0c4)

[4.1.2 堆](#text00010.html#A5d1e0079-a874-4867-abd0-e0315b50c0c3)

[4.1.3 内存布局](#text00010.html#Ab673007b-2077-4c2b-9c01-39ff226f7733)

[4.2 Rust中的资源管理](#text00010.html#Ae886007d-1400-4387-8032-6f1daf25483d)

[4.2.1 变量和函数](#text00010.html#Ad58e007d-482d-40c6-9bf4-97a0e3697788)

[4.2.2 智能指针与RAII](#text00010.html#Ad30b0080-c9a0-4935-887b-e52e3f786bd6)

[4.2.3 内存泄漏与内存安全](#text00010.html#A27810084-7501-4d2d-94f3-4fde8f6a1551)

[4.2.4 复合类型的内存分配和布局](#text00010.html#A397e0089-a79b-49d1-89b7-d11d83950ed6)

[4.3 小结](#text00010.html#A9347008b-2c5d-4c56-a65a-fa25bbd9e95c)

[第5章 所有权系统](#text00011.html#Aec510d2f-6296-4358-8ac6-e9642a53a82b)

[5.1 通用概念](#text00011.html#A2a88008e-0aa6-490e-b72b-7742f41e2647)

[5.2 所有权机制](#text00011.html#A391e0091-e602-424a-acd1-4e8abc6466bb)

[5.3 绑定、作用域和生命周期](#text00011.html#Ada6a0093-3501-4d4e-af5b-fd2d2c672d75)

[5.3.1 不可变与可变](#text00011.html#Aace70094-220a-4292-8694-d89772d82abf)

[5.3.2 绑定的时间属性------生命周期](#text00011.html#A380f0095-9201-4f2c-802c-b64dc0a2ae68)

[5.4 所有权借用](#text00011.html#Afe040099-300c-4525-84c7-503b5d532106)

[5.5 生命周期参数](#text00011.html#A5e9b009d-f3a5-457e-b3fa-344b61377369)

[5.5.1 显式生命周期参数](#text00011.html#A84ba009e-999b-4cc9-b4ae-ea672627da64)

[5.5.2 省略生命周期参数](#text00011.html#A3e3800a5-440a-48d0-9b0a-5d396a54a916)

[5.5.3 生命周期限定](#text00011.html#A4a7800a7-e139-441d-90e7-26bae0baaf7a)

[5.5.4 trait对象的生命周期](#text00011.html#A8bf800a7-94cd-4ca4-814d-f83fc1d8f18d)

[5.6 智能指针与所有权](#text00011.html#A758700a8-5249-402d-a8f1-0f54fb65f530)

[5.6.1 共享所有权Rc＜T＞和Weak＜T＞](#text00011.html#A5e4500ab-673f-43b8-8fa7-c4941187207a)

[5.6.2 内部可变性Cell＜T＞和RefCell＜T＞](#text00011.html#Aa73600ad-2c18-48e7-a43a-0f5cb7310a26)

[5.6.3 写时复制Cow＜T＞](#text00011.html#A82a300af-776c-4af7-b121-e6f47fcc8c56)

[5.7 并发安全与所有权](#text00011.html#Ace9e00b2-354a-4b20-98fb-f3598d6a8a32)

[5.8 非词法作用域生命周期](#text00011.html#A449100b3-cf9c-4750-b4b1-f5aa01a55253)

[5.9 小结](#text00011.html#A52cb00b7-37e4-4c21-a0c2-05bad4706796)

[第6章 函数、闭包与迭代器](#text00012.html#A932a435d-0ff0-4c07-bc05-cc6a9c3804d6)

[6.1 函数](#text00012.html#Ab63400b8-ea97-4c74-950d-929c1b1c1164)

[6.1.1 函数屏蔽](#text00012.html#Aee9900ba-b866-4143-bf4f-d5cddbd51b64)

[6.1.2 函数参数模式匹配](#text00012.html#A41a600ba-2fe7-4d68-a9d2-3cfb9f4fa37c)

[6.1.3 函数返回值](#text00012.html#A542800bb-e67c-4a20-822c-742bb4306465)

[6.1.4 泛型函数](#text00012.html#A1fad00bc-d734-4b90-b041-32c6c6507f81)

[6.1.5 方法与函数](#text00012.html#Aba3200bd-8196-4da9-8145-8885435e6454)

[6.1.6 高阶函数](#text00012.html#A9bde00be-44f0-492e-942e-05e4c5633a11)

[6.2 闭包](#text00012.html#Aa16f00c1-c5eb-4e3c-9aec-544011a53760)

[6.2.1 闭包的基本语法](#text00012.html#Ae21b00c2-8899-41e5-b20d-867f558af6f1)

[6.2.2 闭包的实现](#text00012.html#Aa83c00c3-3bc3-4738-ae4a-8e7a513411f5)

[6.2.3 闭包与所有权](#text00012.html#A6fe200c8-c08a-4638-be93-5b94f13d513b)

[6.2.4 闭包作为函数参数和返回值](#text00012.html#A0d9000ce-e976-4774-af4c-83b0c7d52e25)

[6.2.5 高阶生命周期](#text00012.html#A8d6b00d4-c965-4aa2-bb59-af4c263bbb73)

[6.3 迭代器](#text00012.html#A9e7f00d8-499f-4d1e-9f58-2144eb0226c4)

[6.3.1 外部迭代器和内部迭代器](#text00012.html#A9d0100d8-9482-4a1d-a643-5d4e2e0e08db)

[6.3.2 Iterator trait](#text00012.html#A296d00d9-185d-4e85-a24b-ccad26ee1817)

[6.3.3 IntoIterator trait和迭代器](#text00012.html#Af5e200dd-722e-4668-bf46-14fc5402801c)

[6.3.4 迭代器适配器](#text00012.html#A163e00e0-1340-4c11-bf2a-a015e1a96801)

[6.3.5 消费器](#text00012.html#Ae3e200e5-84a1-41a3-b409-7012790ec2ab)

[6.3.6 自定义迭代器适配器](#text00012.html#Ac59b00e9-6d97-4598-b513-acf25f182e38)

[6.4 小结](#text00012.html#A5a0000ec-0124-4117-acd7-e8a201b8026a)

[第7章 结构化编程](#text00013.html#Afbbb302a-f861-46b8-aeea-299f62d14126)

[7.1 面向对象风格编程](#text00013.html#A618600ef-91a5-44d3-bb03-132ab4794396)

[7.1.1 结构体](#text00013.html#A071c00ef-4650-42e6-b99b-4a5abba64c49)

[7.1.2 枚举体](#text00013.html#Af43300f7-c205-4efc-bb74-d35a7cb14ac8)

[7.1.3 析构顺序](#text00013.html#A40a100fc-2485-4392-aa42-6cc046dbd2e7)

[7.2 常用设计模式](#text00013.html#Ad14900ff-97bd-4618-a403-b7002ef27a85)

[7.2.1 建造者模式](#text00013.html#A72560100-6b43-4480-acc2-c067894b25e0)

[7.2.2 访问者模式](#text00013.html#A69950102-38cc-4009-a282-01c4f4185f5c)

[7.2.3 RAII模式](#text00013.html#Ac55a0105-6270-4004-b7ce-0eb00ff6ba6a)

[7.3 小结](#text00013.html#A73540109-cb15-47fc-8675-c4565c21c51a)

[第8章 字符串与集合类型](#text00014.html#A4671ae18-d9e0-472e-98db-b97ae38af114)

[8.1 字符串](#text00014.html#A062a010a-f8bc-49de-87a5-e70f1d974dce)

[8.1.1 字符编码](#text00014.html#Aad49010a-2a20-47c8-95e2-67353bbc2406)

[8.1.2 字符](#text00014.html#Aae21010d-9b31-4097-ac12-94585d0c8c90)

[8.1.3 字符串分类](#text00014.html#Afa02010f-bcc8-4dad-a0b9-47151a712768)

[8.1.4 字符串的两种处理方式](#text00014.html#A74f40111-3b44-4fb4-ae84-97fd18ff0bef)

[8.1.5 字符串的修改](#text00014.html#A24e80113-2b19-4b25-ac0e-3e6ef090fc18)

[8.1.6 字符串的查找](#text00014.html#A5ba40116-7c3d-4e88-be44-f38795ec2b7f)

[8.1.7 与其他类型相互转换](#text00014.html#A4779011f-bb3b-4c5a-8d4a-27fc226fad16)

[8.1.8 回顾](#text00014.html#Aee090124-7e08-4ec4-b40d-7bca2cb87e48)

[8.2 集合类型](#text00014.html#A83160125-2c61-4f64-8a35-f399f12dca12)

[8.2.1 动态可增长数组](#text00014.html#A573e0125-84a0-47f6-98ca-c618548c5304)

[8.2.2 映射集](#text00014.html#Af40d012f-b051-4627-b963-796784b9bd1b)

[8.3 理解容量](#text00014.html#Aedb70137-a112-447f-b061-d32bcebeae0d)

[8.4 小结](#text00014.html#Adef9013a-69fe-4313-bf9c-26c5738f0b92)

[第9章 构建健壮的程序](#text00015.html#A1042f0df-cd73-4112-891c-8e5756dc2411)

[9.1 通用概念](#text00015.html#A34d3013c-11d5-422f-80bc-14ede5eba42c)

[9.2 消除失败](#text00015.html#Ae419013d-2c4a-4934-bd7c-6c3900e28af8)

[9.3 分层处理错误](#text00015.html#A80cd013f-4dfb-4f98-82c7-560900e1254e)

[9.3.1 可选值Option＜T＞](#text00015.html#A21460140-3eba-4440-a6c7-7b3a1a14c804)

[9.3.2 错误处理Result＜T，E＞](#text00015.html#A80c90144-ba84-4f32-9e74-4cad6e8d8702)

[9.4 恐慌（Panic）](#text00015.html#Af9b70150-8c2d-42da-9546-b2bde4777d7f)

[9.5 第三方库](#text00015.html#A1cb60152-9f22-4f54-a57e-8c89018e72d8)

[9.6 小结](#text00015.html#A3b390155-a6a1-4624-a72d-cff9073edb60)

[第10章 模块化编程](#text00016.html#A4166d824-20de-43e6-9d58-62382f67206d)

[10.1 包管理](#text00016.html#Af05e0157-89ec-4c17-91cd-47b830610486)

[10.1.1 使用Cargo创建包](#text00016.html#Aae9e0157-4ff5-4676-847b-c730af0b2d47)

[10.1.2 使用第三方包](#text00016.html#Af5ea0159-aa33-4e30-af44-8b38dd98b272)

[10.1.3 Cargo.toml文件格式](#text00016.html#Ab9a50161-3e95-4174-9e6b-f2a45687c130)

[10.1.4 自定义Cargo](#text00016.html#A739c0167-f0a8-41e7-8ab4-77be1e302b35)

[10.2 模块系统](#text00016.html#Ab3530169-08b4-428e-ad10-950d0b5347a0)

[10.3 从零开始实现一个完整功能包](#text00016.html#Af56a016e-5141-4c66-84b7-bd191108106e)

[10.3.1 使用Cargo创建新项目](#text00016.html#Ae90d016f-2cf4-4cb0-9216-34c0c9b4346b)

[10.3.2 使用structopt解析命令行参数](#text00016.html#Acebf016f-9e6e-4af3-a483-b55c7d91821a)

[10.3.3 定义统一的错误类型](#text00016.html#Aef7d0171-d463-49cc-bc13-61a8c1dbfc42)

[10.3.4 读取CSV文件](#text00016.html#A0d4c0172-cd7e-4b03-b26b-bdb6e7351b6b)

[10.3.5 替换CSV文件中的内容](#text00016.html#Ab3e60175-f03a-43fd-a28a-8d68e0947085)

[10.3.6 进一步完善包](#text00016.html#Af0fa0177-602c-4e52-aff6-48bf9fa2b7ad)

[10.4 可见性和私有性](#text00016.html#A2db9017c-0b9b-42f1-9b91-6eb42274d867)

[10.5 小结](#text00016.html#Acf11017e-e38f-4bc9-a943-b3aeaa7b47f1)

[第11章 安全并发](#text00017.html#A29dbf5f7-6719-41ed-8b33-7c90928ae4cc)

[11.1 通用概念](#text00017.html#A510f0180-21e4-42be-9b92-5f9c65f15933)

[11.1.1 多进程和多线程](#text00017.html#A03420181-6189-439e-87ee-9b7724b64b79)

[11.1.2 事件驱动、异步回调和协程](#text00017.html#Ac79a0182-fbd7-47a4-b46c-5284d0315594)

[11.1.3 线程安全](#text00017.html#A21430183-eec7-4385-9303-5d21fc4c6f8b)

[11.2 多线程并发编程](#text00017.html#A92b20188-cb28-408c-ae7b-28657fb672a8)

[11.2.1 线程管理](#text00017.html#Ad8850189-5578-41e3-b954-b4a1f7f3915f)

[11.2.2 Send和Sync](#text00017.html#A16bd018d-5bca-4f75-9cef-caabb22a190b)

[11.2.3 使用锁进行线程同步](#text00017.html#A74980191-dad9-4e1b-a556-3f59123a7d4b)

[11.2.4 屏障和条件变量](#text00017.html#Aeab20196-f74f-44fe-a2fe-daefaadafbd8)

[11.2.5 原子类型](#text00017.html#A2e7d0198-a36b-4489-b956-3cae34bc2d1a)

[11.2.6 使用Channel进行线程间通信](#text00017.html#A66e1019a-e598-45a1-81bf-944250701fe7)

[11.2.7 内部可变性探究](#text00017.html#A122001a3-e396-457f-b581-f5170efa0c7d)

[11.2.8 线程池](#text00017.html#A4d5e01a5-0d3c-43be-ac47-ef1c2e51fa29)

[11.2.9 使用Rayon执行并行任务](#text00017.html#Af24501ad-11af-4cb1-9c84-8d2275414ba3)

[11.2.10 使用Crossbeam](#text00017.html#A851ae4e8-0614-43f4-a430-aca86b3b1127)

[11.3 异步并发](#text00017.html#Acfb601b2-dae8-4632-8772-5cf93e4112ec)

[11.3.1 生成器](#text00017.html#A16e201b3-827d-44a2-88b1-8cccd1051712)

[11.3.2 Future并发模式](#text00017.html#Ac7e901b8-985d-48a8-82bc-73eef6bfaf5a)

[11.3.3 async/await](#text00017.html#A113501bb-9ae3-4aec-b820-8b3421af22ad)

[11.4 数据并行](#text00017.html#A4d5401c2-3222-4628-8cee-5f743229de04)

[11.4.1 什么是SIMD](#text00017.html#Af6b501c3-a9fe-4437-94b7-406aefda4e21)

[11.4.2 在Rust中使用SIMD](#text00017.html#A22e801c4-5d7f-4aba-8a94-87b36df59abc)

[11.5 小结](#text00017.html#Aa84f01c8-8041-4ff7-8230-1cf607a1bb2d)

[第12章 元编程](#text00018.html#Aedd163b9-fb37-4d1b-8a1f-5636b6249a5e)

[12.1 反射](#text00018.html#A9c5d01ca-3ec3-4b9c-9d4a-a584eaed38ca)

[12.1.1 通过is函数判断类型](#text00018.html#Af80f01ca-ba27-4b49-b6e2-f05ab1e2b658)

[12.1.2 转换到具体类型](#text00018.html#A0cc201cb-3a13-4ad1-8764-538b00ecb0cc)

[12.1.3 非静态生命周期类型](#text00018.html#Aaf5f01cd-a3c5-4a98-a3e0-5ed39777dff0)

[12.2 宏系统](#text00018.html#Ab09201ce-eb9b-401f-a370-68b9a6b5efd5)

[12.2.1 起源](#text00018.html#A930c01ce-1ef1-48e7-9c8c-70184d1f4633)

[12.2.2 Rust中宏的种类](#text00018.html#Afde701cf-35b7-4674-b4c7-935f403dc5f3)

[12.2.3 编译过程](#text00018.html#A7bc801d0-d9e6-48f6-ad9c-eab428bb39ba)

[12.2.4 声明宏](#text00018.html#Ab3d301d3-c494-41a8-a8f4-febf932845a9)

[12.2.5 过程宏](#text00018.html#A631101e0-9cbd-477c-a6c0-6eb578b20d50)

[12.3 编译器插件](#text00018.html#A69c301ee-815f-4c93-8ae2-a96700392ff0)

[12.4 小结](#text00018.html#A2f2801f1-aa2e-4e4c-8fb9-a5f57a437c2f)

[第13章 超越安全的边界](#text00019.html#Ac1aed812-68b8-41eb-9e8d-4d8a63a9352c)

[13.1 Unsafe Rust介绍](#text00019.html#Ab4e201f3-e88d-4887-835a-27551a55b3d6)

[13.1.1 Unsafe语法](#text00019.html#A007901f4-d243-4640-ac44-7d342c00e7f3)

[13.1.2 访问和修改可变静态变量](#text00019.html#A6f0901f6-07db-47ea-afa7-05fa944a453e)

[13.1.3 Union联合体](#text00019.html#Ac7a501f6-425a-48b5-b2cc-9a7f68a962b0)

[13.1.4 解引用原生指针](#text00019.html#A0ddf01f9-1b1b-480d-8fca-1a4f15a4abf2)

[13.2 基于Unsafe进行安全抽象](#text00019.html#Ab6ff01fa-54b6-4b3b-8f1c-c5bc5280fa4e)

[13.2.1 原生指针](#text00019.html#A442601fa-e0b6-4854-b3da-56b28b195113)

[13.2.2 子类型与型变](#text00019.html#A597601ff-b570-4972-ad9a-aab7157262a4)

[13.2.3 未绑定生命周期](#text00019.html#A85690204-3143-49db-a743-e6376169c7f8)

[13.2.4 Drop检查](#text00019.html#A0dff0205-3006-436c-ad50-c4f1cc121814)

[13.2.5 NonNull＜T＞指针](#text00019.html#A84f2020f-34a5-4004-bfde-fbb659cdbc4f)

[13.2.6 Unsafe与恐慌安全](#text00019.html#A913e0212-3dcf-4249-bde3-9a929592b497)

[13.2.7 堆内存分配](#text00019.html#A66c70212-2621-44ef-b482-f15c5300abd3)

[13.2.8 混合代码内存安全架构三大原则](#text00019.html#Ab6e40214-5365-43a7-99f7-7966807dd4ba)

[13.3 和其他语言交互](#text00019.html#A03c50214-0de0-4629-92a1-855f6c67195c)

[13.3.1 外部函数接口](#text00019.html#A5b540214-ceec-4977-ac23-d0895dfa8c7e)

[13.3.2 与C/C++语言交互](#text00019.html#Aabef0218-5ec2-4b5f-a9f8-d5cbd9f57593)

[13.3.3 使用Rust提升动态语言性能](#text00019.html#Aa8d50226-6a7f-430d-b5a5-ecb2e89cd91b)

[13.4 Rust与WebAssembly](#text00019.html#A96e0022a-976a-406f-b5d8-b7a9c9135ffc)

[13.4.1 WebAssembly要点介绍](#text00019.html#A81e6022b-78a6-47b0-88d2-466ca5057d5f)

[13.4.2 使用Rust开发WebAssembly](#text00019.html#Af1f20231-c430-479f-b410-8e1aeff0aded)

[13.4.3 打造WebAssembly开发生态](#text00019.html#A79db0233-3c68-4343-9c4c-b460861309a8)

[13.5 小结](#text00019.html#A9b790235-2b18-48ed-9cff-91f5561dcdef)

[附录A Rust开发环境指南](#text00020.html#Aee41b2fb-b814-4547-b371-cc28a055c769)

[附录B Rust如何调试代码](#text00021.html#A8db3454a-e77e-47ad-be4c-24fb83b860ed)

[]{#text00007.html}
